
import sys
# IMPORTING ALL THE NECESSERY PYSIDE2 MODULES FOR OUR APPLICATION.
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import (QCoreApplication, QPropertyAnimation, QDate, QDateTime, QMetaObject, QObject, QPoint, QRect,
                          QSize, QTime, QUrl, Qt, QEvent, QRectF, pyqtSignal)
from PyQt5.QtGui import (QBrush, QColor, QConicalGradient, QCursor, QFont, QFontDatabase, QIcon, QKeySequence,
                         QLinearGradient, QPalette, QPainter, QPixmap, QRadialGradient)
from PyQt5.QtWidgets import *

from ui_main2 import Ui_MainWindow  # MAINWINDOW CODE GENERATED BY THE QT DESIGNER AND pyside2-uic.

import matplotlib

matplotlib.use("Qt5Agg")  # 声明使用QT5
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib import pyplot
import numpy as np
from scipy.signal import butter, lfilter
import threading
import time
import pickle
import pandas as pd
from wfdb import processing
from tensorflow import keras
from tensorflow.keras.layers import Dense, Input, Dropout, Convolution1D, MaxPool1D, GlobalMaxPool1D, \
    GlobalAveragePooling1D, concatenate
import serial  # 导入模块
from collections import deque

SAMPLEFZ = 512
DATASIZE = SAMPLEFZ * 60
PLOTSIZE = SAMPLEFZ * 2
BOXHEIGHT = 230

DEBUG = True

SYNC = 0xAA
EXCODE = 0x55
PARSER_POOR_SIGNAL_CODE = 0x02
PARSER_HEARTRATE_CODE = 0x03
PARSER_CONFIG_CODE = 0x08
PARSER_RAW_CODE = 0x80
PARSER_DEBUG1_CODE = 0x84
PARSER_DEBUG2_CDE = 0x85


class MySignal(QObject):
    label_show = pyqtSignal(QLabel, str)
    coordinate_show = pyqtSignal(np.ndarray)
    progress_show = pyqtSignal(QProgressBar, int)
    img_show = pyqtSignal(int)


class DataCollect(threading.Thread):
    """
    读取bmd101芯片数据
    """

    def __init__(self):
        threading.Thread.__init__(self)
        self.currdata = []
        self.data = []
        self.com = "COM3"
        self.baud = 57600
        self.ser = None
        self.flag = False

        self.q = deque(maxlen=DATASIZE)

    def set_com(self, com="COM3"):
        # 端口，GNU / Linux上的/ dev / ttyUSB0 等 或 Windows上的 COM3 等
        self.com = com

    def set_baud(self, baud=57600):
        # 波特率，标准值之一：50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200
        self.baud = baud

    def get_data(self):
        return list(self.q)

    # 读串口数据
    def run(self):
        # 循环接收数据
        print(":::")
        while self.flag:
            if self.ser is not None and self.ser.in_waiting:
                STRGLO = self.ser.read(self.ser.in_waiting)
                streams = bytes(STRGLO).split(b'\xaa\xaa')
                # print(streams)
                for stream in streams:
                    if len(stream) < 4:
                        continue

                    readbyte = 0
                    # Parse [PLENGTH] byte
                    pLength = stream[readbyte]
                    readbyte += 1
                    if (pLength > 169):
                        continue
                    # Collect [PAYLOAD...] bytes
                    if (readbyte + pLength > len(stream)):
                        continue
                    payload = stream[readbyte:readbyte + pLength]

                    readbyte += pLength
                    if (readbyte >= len(stream)):
                        continue
                    # Calculate [PAYLOAD...] checksum
                    checksum = 0
                    for i in range(pLength):
                        checksum += payload[i]
                    checksum &= 0xFF
                    checksum = ~checksum & 0xFF
                    # Parse [CKSUM] byte
                    c = stream[readbyte]
                    # Verify [CKSUM] byte against calculated [PAYLOAD...] checksum
                    if (c != checksum):
                        continue
                    # Since [CKSUM] is OK, parse the Data Payload
                    value = self.parsePayload(payload, pLength)
                    # self.currdata.append( value)
                    self.q.append([time.time(), value])
        print("stop")

    # 打开串口
    # 超时设置,None：永远等待操作，0为立即返回请求结果，其他值为等待超时时间(单位为秒）
    def DOpenPort(self, timeout):
        if self.ser is not None and self.ser.is_open:
            return True
        try:
            # 打开串口，并得到串口对象
            print("打开串口 port:", self.com, " baud:", self.baud, "timeout:", timeout)
            self.ser = serial.Serial(self.com, self.baud, timeout=timeout)
            # 判断是否打开成功
            if (self.ser.is_open):
                self.flag = True
                print("---成功---")
                return True
        except Exception as e:
            print("---异常---：", e)
        return False

    # 关闭串口
    def DColsePort(self):
        self.flag = False
        if self.ser:
            self.ser.close()
        print("关闭串口")
        self.ser = None

    # 写串口数据
    def DWritePort(self, text):
        if not self.ser.is_open:
            return -1
        result = self.ser.write(text.encode("gbk"))  # 写数据
        return result

    def parsePayload(self, payload, pLength):
        bytesParsed = 0
        length = 0
        # Parse the extendedCodeLevel, code, and length
        extendedCodeLevel = 0
        while (payload[bytesParsed] == EXCODE):
            extendedCodeLevel += 1
            bytesParsed += 1

        code = payload[bytesParsed]
        bytesParsed += 1
        if (code == 128 and bytesParsed < pLength):
            length = 2
            bytesParsed += 1
        else:
            length = 1
        # print( "EXCODE level:",extendedCodeLevel,"CODE: ",code," length",length )
        if code == PARSER_HEARTRATE_CODE:
            # print("case0",payload[bytesParsed])
            pass
        elif code == PARSER_POOR_SIGNAL_CODE:
            # print("case1",payload[bytesParsed])
            pass
        elif code == PARSER_RAW_CODE:
            if bytesParsed >= pLength:
                return 0
            RawWaveValue = (payload[bytesParsed] * 256) + payload[bytesParsed + 1]
            if RawWaveValue > 32768:
                RawWaveValue -= 65536
            return RawWaveValue
            # print("Data value(s):",RawWaveValue)
        return 0

class NtrINN_Model():
    def __init__(self):
        self.model = keras.models.load_model("my_model0")

    def predict(self, rr):
        """shape(None,60, 1)"""
        return self.model.predict(rr)

    def pl_map(self, model_predict_val):
        pl = np.array([0, 0.1, 0.2, 0.3, 0.5, 0.8, 1])
        return np.argmin(np.abs(pl-model_predict_val)) + 2


class SVM_Model():

    def __init__(self):
        self.model = None
        with open("svm_model.pkl", 'rb') as f:
            self.model = pickle.load(f)

    def predict(self, rr):
        """shape(None,60, 1)"""
        rr = np.squeeze(rr, -1)
        return [self.model.predict(rr)]

    def pl_map(self, model_predict_val):
        return model_predict_val * 6 + 2


class ECGNN_Model():
    def __init__(self):
        self.model = keras.models.load_model("my_model1")

    def predict(self, rr):
        """shape(None,60, 1)"""
        m = np.mean(rr)
        return self.model.predict(rr / m)

    def pl_map(self, model_predict_val):
        return model_predict_val * 6 + 2


class NN2_Model():
    def __init__(self):
        self.model = keras.models.load_model("my_model2")

    def predict(self, rr):
        """shape(None,60, 1)"""
        return self.model.predict(rr)

    def pl_map(self, model_predict_val):
        return model_predict_val * 6 + 2


class ECG_Processor(object):

    def __init__(self):
        """
        QRSDetectorOffline class initialisation method.
        :param string ecg_data_path: path to the ECG dataset
        :param bool verbose: flag for printing the results
        :param bool log_data: flag for logging the results
        :param bool plot_data: flag for plotting the results to a file
        :param bool show_plot: flag for showing generated results plot - will not show anything if plot is not generated
        """

        self.signal_frequency = 512  # Set ECG device frequency in samples per second here.

        self.filter_lowcut = 0.00001
        self.filter_highcut = 15.0
        self.filter_order = 1

        self.integration_window = 30  # Change proportionally when adjusting frequency (in samples).

        self.findpeaks_spacing = 200  # Change proportionally when adjusting frequency (in samples).

        self.refractory_period = 240  # Change proportionally when adjusting frequency (in samples).
        self.qrs_peak_filtering_factor = 0.125
        self.noise_peak_filtering_factor = 0.125
        self.qrs_noise_diff_weight = 0.25

        # Measured and calculated values.
        self.filtered_ecg_measurements = None
        self.differentiated_ecg_measurements = None
        self.squared_ecg_measurements = None
        self.integrated_ecg_measurements = None
        self.detected_peaks_indices = None
        self.detected_peaks_values = None

        # Detection results.
        self.qrs_peaks_indices = np.array([], dtype=int)
        self.noise_peaks_indices = np.array([], dtype=int)
        self.condidate_index = np.array([], dtype=float)

        # Final ECG data and QRS detection results array - samples with detected QRS are marked with 1 value.
        self.ecg_data_detected = None

    def get_RRs(self, ecg_signals, ecg_times):
        self.detect_peaks(ecg_signals)
        return self.detect_qrs(ecg_signals, ecg_times)

    def get_filtered_data(self, data):
        ecg_signals, ecg_times = self.load_ecg_data(data)
        # Measurements filtering - 0-15 Hz band pass filter.
        self.filtered_ecg_measurements = self.bandpass_filter(ecg_signals, lowcut=self.filter_lowcut,
                                                              highcut=self.filter_highcut,
                                                              signal_freq=self.signal_frequency,
                                                              filter_order=self.filter_order)
        if len(self.filtered_ecg_measurements) > 10:
            self.filtered_ecg_measurements[:5] = self.filtered_ecg_measurements[5]

        return self.filtered_ecg_measurements

    def read_ecg_file(self, filename):
        """
        Method loading ECG data set from a file.
        """
        data = pd.read_table(filename, sep='\s+')
        data = np.array(data.values)
        return data

    def load_ecg_data(self, data):
        """
        Method loading ECG data set from a file.
        """
        times = np.array(data[:, 0], dtype=np.str)
        ecg_times = np.empty(times.shape)
        for i in range(len(times)):
            ecg_times[i] = float(times[i][:-1])
        ecg_times -= ecg_times[0]

        dif = 0
        for i in range(1, len(ecg_times)):
            dif += 1
            if ecg_times[i] != ecg_times[i - 1]:
                ternal = (ecg_times[i] - ecg_times[i - 1]) / dif
                for j in range(1, dif):
                    ecg_times[i - j] = ecg_times[i] - j * ternal
                dif = 0

        self.ecg_signals = np.array(data[:, 1], dtype=np.float)
        self.ecg_times = ecg_times

        return self.ecg_signals, self.ecg_times
        # peaks_hr(self.ecg_signals, title= 'ecg_signals')

    def detect_peaks(self, ecg_signals):
        """
        Method responsible for extracting peaks from loaded ECG measurements data through measurements processing.
        """
        # peaks_hr(self.filtered_ecg_measurements, title= 'filtered_ecg_measurements')

        # Derivative - provides QRS slope information.
        self.differentiated_ecg_measurements = np.ediff1d(self.filtered_ecg_measurements)

        # Squaring - intensifies values received in derivative.
        self.squared_ecg_measurements = self.differentiated_ecg_measurements ** 2

        # Moving-window integration.
        self.integrated_ecg_measurements = np.convolve(self.squared_ecg_measurements, np.ones(self.integration_window))

        # peaks_hr(self.integrated_ecg_measurements, title= 'integrated_ecg_measurements')

        # Fiducial mark - peak detection on integrated measurements.
        self.detected_peaks_indices = self.findpeaks(data=self.integrated_ecg_measurements,
                                                     limit=None,
                                                     spacing=self.findpeaks_spacing)

    """QRS detection methods."""

    def detect_qrs(self, ecg_signals, ecg_times):
        """
        Method responsible for classifying detected ECG measurements peaks either as noise or as QRS complex (heart beat).
        """
        condidate_index = []
        max_bpm = 130
        search_radius = int(512 * 60 / max_bpm)
        self.detected_peaks_indices = processing.correct_peaks(ecg_signals, peak_inds=self.detected_peaks_indices,
                                                               search_radius=search_radius, smooth_window_size=150)
        self.detected_peaks_indices = np.unique(self.detected_peaks_indices)
        self.detected_peaks_indices = self.detected_peaks_indices[self.detected_peaks_indices > 0]
        condidate_index = self.detected_peaks_indices

        if len(condidate_index) == 0:
            print("1")
            return np.array([])
        s = ecg_signals[condidate_index] / np.mean(ecg_signals[condidate_index])
        condidate_index = condidate_index[np.bitwise_and(0 < s, s < 1.5)]
        # peaks_hr(self.ecg_signals, peak_inds=condidate_index, title='3')
        res = np.diff(ecg_times[condidate_index])
        res = res[res > 0.4]
        res = res[res < 1.4]
        if len(res) == 0:
            print('=====null=======')
            return res
        length = -1
        # plt.figure(figsize=(20,4))
        # plt.plot(np.arange(len(res)),res,'--')
        while len(res) != length:
            length = len(res)
            m = np.mean(res)
            res = res[np.abs(res - m) < m * 0.5]
        return res

    def bandpass_filter(self, data, lowcut, highcut, signal_freq, filter_order):
        """
        Method responsible for creating and applying Butterworth filter.
        :param deque data: raw data
        :param float lowcut: filter lowcut frequency value
        :param float highcut: filter highcut frequency value
        :param int signal_freq: signal frequency in samples per second (Hz)
        :param int filter_order: filter order
        :return array: filtered data
        """
        nyquist_freq = 0.5 * signal_freq
        low = lowcut / nyquist_freq
        high = highcut / nyquist_freq
        b, a = butter(filter_order, [low, high], btype="band")
        y = lfilter(b, a, data)
        return y

    def findpeaks(self, data, spacing=1, limit=None):
        """
        Finds peaks in `data` which are of `spacing` width and >=`limit`.
        :param ndarray data: data
        :param float spacing: minimum spacing to the next peak (should be 1 or more)
        :param float limit: peaks should have value greater or equal
        :return array: detected peaks indexes array
        """
        len = data.size
        x = np.zeros(len + 2 * spacing)
        x[:spacing] = data[0] - 1
        x[-spacing:] = data[-1] - 1
        x[spacing:spacing + len] = data
        peak_candidate = np.zeros(len)
        peak_candidate[:] = True
        for s in range(spacing):
            start = spacing - s - 1
            h_b = x[start: start + len]  # before
            start = spacing
            h_c = x[start: start + len]  # central
            start = spacing + s + 1
            h_a = x[start: start + len]  # after
            peak_candidate = np.logical_and(peak_candidate, np.logical_and(h_c > h_b, h_c > h_a))

        ind = np.argwhere(peak_candidate)
        ind = ind.reshape(ind.size)
        if limit is not None:
            ind = ind[data[ind] > limit]
        return ind


class Model():
    def __init__(self):
        self.ecg_processor = ECG_Processor()
        self.model0 = NtrINN_Model()
        self.model1 = ECGNN_Model()
        self.model2 = NN2_Model()
        self.analyzer = self.model0

        self.analyzer.predict(np.array([i for i in range(60)]).reshape(-1, 60, 1))
        self.mode = "DEBUG"
        self.collecting = False
        self.recording = False
        a = np.array([i for i in range(DATASIZE * 10)])
        b = 5000 * np.sin([i / 31.41519 for i in range(DATASIZE * 10)])
        self.playback_data = np.vstack([a, b]).T
        self.playback_index = 0
        self.st_pldata = []
        self.lt_pldata = []
        self.conn = DataCollect()
        self.val1 = 0.5
        self.val2 = 0
        self.val3 = 0
        self.avg_hr = 80
        self.Warning = False
        self.tired = False
        self.drink = False

    def change_mode(self, mode, model):
        if mode == "Online":
            self.val1 = 0.5
            self.val2 = 0
            self.val3 = 0
            self.st_pldata = []
            self.lt_pldata = []
        if model == 0:
            self.analyzer = self.model0
        elif model == 1:
            self.analyzer = self.model1
        elif model == 2:
            self.analyzer = self.model2
        self.Warning = False
        self.mode = mode

    def read_file(self, filename):
        self.playback_index = 0
        if "ECGLog" in filename:
            data = self.ecg_processor.read_ecg_file(filename)
            ecg_signals, ecg_times = self.ecg_processor.load_ecg_data(data)
            self.playback_data = np.vstack([ecg_times, ecg_signals]).T


    def start_collect(self,com="COM3", baud=57600):
        if self.collecting:
            self.stop_collect()
            return True
        self.conn = DataCollect()
        self.conn.set_baud(baud)
        self.conn.set_com(com)
        ret = self.conn.DOpenPort(3)
        if ret:
            self.conn.start()
            print("串口开启")
            self.collecting = True
            return True
        else:
            print("串口读取异常")
            self.collecting = False
            return False

    def stop_collect(self):
        self.conn.DColsePort()
        self.collecting = False

    def get_data(self):
        if self.mode == "Debug":
            index = self.playback_index
            if len(self.playback_data) - index < DATASIZE:
                return self.playback_data[index:]
            self.playback_index += SAMPLEFZ // 5
            index = self.playback_index
            return self.playback_data[index:index + DATASIZE]
        if self.collecting is False:
            return np.vstack([np.array([i for i in range(DATASIZE)]), np.zeros(DATASIZE)]).T

        curdata = np.array(self.conn.get_data())
        if len(curdata) == 0:
            return curdata
        ecg_signals = curdata[:, 1]
        if len(ecg_signals[-PLOTSIZE:][ecg_signals[-PLOTSIZE:] > 10000]) > 40:
            self.Warning = True
            return np.vstack([np.array([i for i in range(DATASIZE)]), np.zeros(DATASIZE)]).T
        else:
            self.Warning = False
        return curdata

    def get_filtered_signal(self, data):
        return self.ecg_processor.get_filtered_data(data)

    def process_data(self, ecg_signals, ecg_times):
        # 用网络处理数据获得结果
        """@return {疲劳指数0, 疲劳值1，清醒值2，平均心率3, 预测值4, 其他5...n}"""
        values = [self.val1, sum(self.lt_pldata) //60, 100-sum(self.lt_pldata) // 60, 0, 0]

        if self.mode == "Online" and not self.collecting:
            return values
        if self.mode == "Online" and self.Warning:
            return values
        ecg_signals = np.array(ecg_signals)

        if len(ecg_signals) < PLOTSIZE:
            return values
        rr = self.ecg_processor.get_RRs(ecg_signals, ecg_times)

        a = len(rr)
        if a == 0:
            return values
        if a < 60:
            b = 60 // a
            rr = np.concatenate([rr for i in range(b + 1)])

        rr = rr[-60:]
        # print(rr)
        res = self.analyzer.predict(rr.reshape(-1, 60, 1))

        # res = ((2*res-1)**7+1)/2
        val = res[0][0]
        real_val = 10 * self.analyzer.pl_map(val)

        if len(res) > 0:
            values[4] = str(round(real_val / 10))
        else:
            values[4] = ""
        print(val, real_val)

        self.st_pldata.append(real_val)
        self.lt_pldata.append(real_val)

        st_val = 50
        if len(self.st_pldata) > 10:
            self.st_pldata = self.st_pldata[-10:]
            st_val = sum(self.st_pldata) / 10
        lt_val = 50
        if len(self.lt_pldata) > 60:
            self.lt_pldata = self.lt_pldata[-60:]
            lt_val = sum(self.lt_pldata) / 60
        values[1] = int(lt_val)
        values[2] = 100 - values[1]

        self.val1 = 0.95 * self.val1 + 0.04 * lt_val + 0.01 * st_val
        values[0] = int((0.96 * self.val1-50)*8/6)+50  # 疲劳程度
        values[0] = min(90,max(values[0],10))
        values[3] = int(3600 / sum(rr))  # 平均心率
        self.tired = values[0] > 80 and not self.Warning
        # self.drink = values[1] > 50 and not self.Warning
        return values


class Controller(threading.Thread):

    def __init__(self):
        threading.Thread.__init__(self)
        self.model = Model()
        self.view = MainWindow()
        # 绑定按钮事件
        self.view.ui.bn_bug_start.clicked.connect(self.startReadingData)
        self.view.ui.horizontalSlider.valueChanged.connect(self.changeMode)
        self.view.ui.bn_bug_load.clicked.connect(self.openFile)

        self.flag = False
        self.view.show()
        time.sleep(1)
        self.changeMode()

    def stop(self):
        self.flag = False

    def startReadingData(self):
        if not self.model.collecting:
            port = self.view.ui.comboBox_bug.currentText()
            rt = self.model.start_collect(com=port)
            if rt:
                self.view.ui.bn_bug_start.setText("stop")
        else:
            self.model.stop_collect()
            self.view.ui.bn_bug_start.setText("open")


    def changeMode(self):
        mode = self.view.ui.horizontalSlider.value()
        m = 0
        if mode == 1:
            m = self.view.setCheckModel(True)
            self.model.change_mode("Debug", m)

        elif mode == 0:
            m = self.view.setCheckModel(False)
            self.model.change_mode("Online", m)

        print("模式：",mode,"模型：", m)

    def openFile(self):
        if self.model.mode != "Debug":
            return
        filename = QFileDialog.getOpenFileUrl()
        # (PyQt5.QtCore.QUrl('file:///E:/心电疲劳项目/heart/ECGLog-126.txt'), 'All Files (*)')
        print(filename)
        if filename:
            file = filename[0].toString()[8:]
            print(file)
            self.model.read_file(file)

    def run(self):
        self.flag = True
        time.sleep(1.5)
        sec = 0

        while self.flag:
            if self.view.isclosed:
                self.model.stop_collect()
                break
            time.sleep(0.2)
            sec = (sec + 1) % 300
            newdata = self.model.get_data()

            # if not self.model.Warning:
            ecg_signals = self.model.get_filtered_signal(newdata)
            ecg_times = newdata[:, 0]

            values = self.model.process_data(ecg_signals, ecg_times)
            self.view.showBoxValues(values[0:3])
            if sec % 5 == 0:
                self.view.showDebugInfo(values[4])
            self.view.showAvgHeartRate(values[3])
            self.view.showCoordinate(ecg_signals[-PLOTSIZE:])

            if self.model.mode == "Online" and not self.model.collecting:
                if sec % 5 <= 3:
                    self.view.showWarning("串口未开启")
                else:
                    self.view.showWarning("")
                continue

            elif self.model.Warning:
                if sec % 5 <= 3:
                    self.view.showWarning("异常数据!")
                else:
                    self.view.showWarning("")

            elif self.model.drink:
                if sec % 5 <= 3:
                    self.view.showWarning("醉酒驾驶!")
                else:
                    self.view.showWarning("")

            elif self.model.tired:
                if sec % 5 <= 3:
                    self.view.showWarning("疲劳驾驶!")
                else:
                    self.view.showWarning("")
            else:
                self.view.showWarning("")



class MainWindow(QMainWindow):
    def __init__(self):

        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.isclosed = False

        # ----> SET WINDOW TITLE AND ICON
        applicationName = ""
        self.setWindowTitle(
            applicationName)
        #############################################################
        # width = self.ui.graphicsView.width()
        # height = self.ui.graphicsView.height()
        self.coordinate = Figure_Canvas(width=450, height=20)
        self.ui.verticalLayout_coordinate.addWidget(self.coordinate)

        self.item1 = boxTypeItem("pl")
        self.item1.setPos(180, 40)
        self.scene = QtWidgets.QGraphicsScene(0, 0, 430, 250)
        self.ui.graphicsView_2.setScene(self.scene)
        self.ui.graphicsView_2.setSceneRect(0, 0, 430, 250)
        self.ui.graphicsView_2.setBackgroundBrush(QColor(236, 236, 236))
        self.ui.graphicsView_2.setRenderHint(QPainter.Antialiasing)
        self.scene.addItem(self.item1)
        self.ui.radioButton_model1.setChecked(True)
        self.setCheckModel(False)

        self.ms = MySignal()
        self.ms.label_show.connect(self.drawLabel)
        self.ms.coordinate_show.connect(self.drawCoordinate)
        self.ms.img_show.connect(self.drawBoxValue)
        self.ms.progress_show.connect(self.drawProgressBar)


    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        self.isclosed = True

    def drawLabel(self, lb, info):
        lb.setText(info)

    def drawCoordinate(self, data):
        self.coordinate.showImage(data)

    def drawBoxValue(self, val):
        self.item1.setHeight(val)
        self.item1.update()

    def drawProgressBar(self, pb, val):
        pb.setValue(val)

    def showCoordinate(self, data):
        self.ms.coordinate_show.emit(data)
        # self.coordinate.showImage(data)

    def showAvgHeartRate(self, val):
        self.ms.label_show.emit(self.ui.label_avghr, str(val))
        # self.ui.label_avghr.setText(str(val))

    def showDebugInfo(self, info):
        self.ms.label_show.emit(self.ui.label_debuginfo, str(info))
        # self.ui.label_debuginfo.setText(str(info))

    def showBoxValues(self, values):
        self.ms.progress_show.emit(self.ui.progressBar_bug_pl, values[1])
        self.ms.progress_show.emit(self.ui.progressBar_bug_qx, values[2])
        self.ms.img_show.emit(values[0])

        # self.ui.progressBar_bug_pl.setValue(values[1])
        # self.ui.progressBar_bug_qx.setValue(values[2])
        # self.item1.setHeight(values[0])
        # self.item1.update()

    def showWarning(self, warning_text):
        self.ms.label_show.emit(self.ui.label_warning, warning_text)
        # self.ui.label_warning.setText(warning_text)

    def setCheckModel(self, state):
        model = 0
        if self.ui.radioButton_model1.isChecked():
            model = 0
        elif self.ui.radioButton_model2.isChecked():
            model = 1
        elif self.ui.radioButton_model3.isChecked():
            model = 2

        self.ui.radioButton_model1.setEnabled(state)
        self.ui.radioButton_model2.setEnabled(state)
        self.ui.radioButton_model3.setEnabled(state)

        return model



class boxTypeItem(QGraphicsItem):
    """进度条类控件"""

    def __init__(self, id):
        super(boxTypeItem, self).__init__()
        self.id = id
        self.w = 60
        self.h = 0 * BOXHEIGHT // 100
        self.t = 8
        self.color = QColor(255, 255, 255)
        self.setHeight(self.h)

    def boundingRect(self):
        return QRectF(0, 0, 100, BOXHEIGHT + 30)

    def setHeight(self, height):
        self.h = height * BOXHEIGHT // 100
        r, g, b = 0, 0, 0
        if self.id == "pl":
            if height < 50:  # 0,255,10 -> 255,170,10
                r = int(height * 255 // 50)
                g = int(255 - height * 85 // 50)
                b = 0
            else:  # 255,170,10 -> 255,0, 10
                height -= 50
                r = 255
                g = int(170 - height * 170 // 50)
                b = 0
        elif self.id == "zj":
            if height < 40:  # 0 255 0 -> 85 170 255
                r = int(height * 85 // 40)
                g = int(255 - height * 85 // 40)
                b = int(height * 255 // 40)
            elif height < 70:  # 85 170 255 -> 255 170 0
                height -= 40
                r = int(85 + height * 170 // 30)
                g = 170
                b = int(255 - height * 255 // 30)
            else:  # 255 170 0 -> 255 0 0
                height -= 60
                r = 255
                g = int(170 - height * 170 // 40)
                b = 0
        elif self.id == "hr":
            if height < 20:
                r = 255
                g = 0
                b = 0
            elif height < 50:  # 255 0 0 -> 0 255 0
                height -= 20
                r = int(255 - height * 255 // 30)
                g = int(height * 255 // 30)
                b = 0
            elif height < 80:  # 0 255 0 -> 255 0 0
                height -= 50
                r = int(height * 255 // 30)
                g = int(255 - height * 255 // 30)
                b = 0
            else:
                r = 255
                g = 0
                b = 0
        self.color = QColor(r, g, b)

    def paint(self, painter, option, widget=None):
        w, h, t = self.w, BOXHEIGHT // 4, self.t
        leftw = 0
        step = self.h
        color = self.color
        # font = {'family': 'Times New Roman', 'weight': 'normal', 'size': 30}
        # painter.setFont(font)
        painter.drawText(QPoint(-55, t * 5), "严重 -")
        painter.drawText(QPoint(-55, t * 5 + 1 * BOXHEIGHT // 3), "中等 -")
        painter.drawText(QPoint(-55, t * 5 + 2 * BOXHEIGHT // 3), "轻度 -")

        # 底部椭圆
        # painter.save()
        bottomrect = QRectF(leftw, h * 4 - 10, w, 2 * t)
        bottomlinear = QLinearGradient(leftw, h * 4 - step, w, step)
        bottomlinear.setColorAt(0, color)
        bottomlinear.setColorAt(0.3, color.lighter(200))
        bottomlinear.setColorAt(0.35, color.lighter(180))
        bottomlinear.setColorAt(0.9, color.darker(200))
        bottomlinear.setColorAt(1, color)
        bottomlinear.setStart(leftw, h)
        bottomlinear.setFinalStop(leftw + w, h)
        painter.setPen(Qt.NoPen)
        painter.setBrush(bottomlinear)
        painter.drawEllipse(bottomrect)
        # painter.restore()

        # 背景
        # painter.save()
        bgLinearGradient = QLinearGradient(leftw, h * 2, w, h * 4)
        bgLinearGradient.setColorAt(0, QColor("#A8C0D0"))
        bgLinearGradient.setColorAt(0.3, QColor("#CFDBE3"))
        bgLinearGradient.setColorAt(0.35, QColor("#A2BBCC").lighter(120))
        bgLinearGradient.setColorAt(0.9, QColor("#767775").lighter(120))
        bgLinearGradient.setColorAt(1, QColor("#A8C0D0"))
        bgLinearGradient.setStart(leftw, h)
        bgLinearGradient.setFinalStop(leftw + w, h)
        bgrect = QRectF(leftw, 0, w, h * 4)
        painter.fillRect(bgrect, bgLinearGradient)
        # painter.restore()

        # 中间
        # painter.save()
        midrect = QRectF(leftw, h * 4 - step, w, step)
        midLinearGradient = QLinearGradient(leftw, h * 4 - step, w, step)
        midLinearGradient.setColorAt(0, color)
        midLinearGradient.setColorAt(0.3, color.lighter(200))
        midLinearGradient.setColorAt(0.35, color.lighter(180))
        midLinearGradient.setColorAt(0.9, color.darker(200))
        midLinearGradient.setColorAt(1, color)
        midLinearGradient.setStart(leftw, h)
        midLinearGradient.setFinalStop(leftw + w, h)
        painter.fillRect(midrect, midLinearGradient)
        # painter.restore()

        # 上边椭圆
        # painter.save()
        painter.setPen(Qt.NoPen)
        fade3 = QLinearGradient(leftw, 2 * h - 2 * t, w, 4 * h)
        fade3.setColorAt(0, QColor("#A8C0D0"))
        fade3.setColorAt(0.9, QColor("#CFDBE3"))
        fade3.setColorAt(0.35, QColor("#A2BBCC").darker(120))
        fade3.setColorAt(0.3, QColor("#767775").darker(120))
        fade3.setColorAt(0, QColor("#A8C0D0"))
        fade3.setStart(leftw, h - 2 * t)
        fade3.setFinalStop(leftw, h + 2 * t)
        painter.setBrush(fade3)
        rectangle = QRectF(leftw, -t, w, 2 * t)
        painter.drawEllipse(rectangle)
        # painter.restore()

        # 中间椭圆
        # painter.save()
        midtoprect = QRectF(leftw, h * 4 - step - t, w + 0.5, 2 * t)
        midtoplinear = QLinearGradient(leftw, h * 4 - step, w, step)
        if step == 0:
            midtoplinear.setColorAt(0, QColor("#A8C0D0"))
            midtoplinear.setColorAt(0.9, QColor("#CFDBE3"))
            midtoplinear.setColorAt(0.35, QColor("#A2BBCC"))
            midtoplinear.setColorAt(0.3, QColor("#767775"))
            midtoplinear.setColorAt(0, QColor("#A8C0D0"))
            midtoplinear.setStart(leftw, h - 2 * t)
            midtoplinear.setFinalStop(leftw, h + 2 * t)
        else:
            midtoplinear.setColorAt(0, color.darker(100))
            midtoplinear.setColorAt(0.3, color.darker(100))
            midtoplinear.setColorAt(0.35, color.darker(100))
            midtoplinear.setColorAt(0.9, color.darker(100))
            midtoplinear.setColorAt(1, color.darker(100))
            midtoplinear.setStart(leftw, h)
            midtoplinear.setFinalStop(leftw + w, h)
        painter.setPen(Qt.NoPen)
        painter.setBrush(midtoplinear)
        painter.drawEllipse(midtoprect)
        # painter.restore()
        # self.update()


class Figure_Canvas(FigureCanvas):

    def __init__(self, width=11, height=5, parent=None, dpi=50):
        """ #CFCFCF - #228EFF
        #5B5A5A - #AFEEEE
        """
        fig = Figure(figsize=(width, height), facecolor='#CFCFCF', dpi=dpi, linewidth=0)
        FigureCanvas.__init__(self, fig)  # 初始化父类
        self.setParent(parent)
        self.fig = pyplot.figure(figsize=(width, height), facecolor='#CFCFCF', dpi=dpi)
        self.axes = fig.add_subplot(111, frame_on=False)
        self.showImage([0])

    def showImage(self, data, xmin=0, xmax=PLOTSIZE):
        self.axes.cla()
        self.axes.plot(data, color="#228EFF", linestyle='-')
        self.axes.set_facecolor('#CFCFCF')
        font = {'weight': 'normal', 'size': 30}
        self.axes.set_ylim(-6000, 6000)
        self.axes.set_yticks([-3000, 0, 3000])
        self.axes.set_yticklabels([])
        self.axes.set_ylabel("heart rate", font)
        self.axes.set_xlim(xmin, xmax)
        ts = (xmax - xmin) // 4
        self.axes.set_xticks([xmin + ts * i for i in range(5)])
        self.axes.set_xticklabels([])
        self.axes.set_xlabel("time", font)

        self.axes.grid()
        self.draw()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    logi = Controller()
    logi.start()
    sys.exit(app.exec_())

############################################################################################################################################################